# PokerCard-Recognition-System

## 1. Introducción  
La arquitectura del sistema sigue un flujo de trabajo jerárquico y secuencial. Todo comienza con el análisis de la imagen completa, donde se segmentan y aíslan una por una las cartas que aparecen. Este paso es esencial para reducir la complejidad del problema y enfocar los recursos computacionales solo en las partes relevantes de la imagen.
Una vez aislada cada carta, el sistema pasa a una etapa más específica, donde analiza sus componentes internos: los palos (picas, corazones, tréboles, rombos) y las figuras (A, K, Q, J, 10, etc.). La correcta identificación de estos elementos es clave para poder clasificar bien cada carta.
Para que la máquina pueda interpretar la forma de cada motivo (palo o figura), es necesario convertirla a un formato numérico. Para eso, se calcula un vector de características basado en los Momentos de Hu para cada motivo segmentado. Esta técnica se eligió porque permite obtener una representación del objeto que no se ve afectada por traslaciones, escalas o rotaciones, lo cual es muy común en este tipo de aplicaciones. Estos vectores son los que se usan luego para entrenar un modelo de aprendizaje automático que los asocia con sus etiquetas correspondientes (por ejemplo, 'K' o 'Corazones').

## 2. Desarrollo  
El flujo de trabajo del proyecto sigue una secuencia lógica y bien estructurada, desde el inicio hasta el final. Todo empieza con las imágenes en bruto, que se procesan con el primer script, generador_paso1.py. Este se encarga de detectar y extraer las cartas presentes en cada imagen y, dentro de ellas, aislar los motivos (palo y figura). Para cada motivo, se calcula su "huella digital" en forma de vector numérico usando los Momentos de Hu, los cuales son transformados logarítmicamente para mejorar su utilidad. Toda esta información estructural se guarda en un archivo de datos .npz. Se han utilizado en total 242 imágenes de entrenamiento y 87 de test.
Luego, ese archivo se abre con la herramienta de etiquetado, etiquetar_cartas_paso2.py, que permite al usuario asignar manualmente la etiqueta correcta a cada motivo y carta. Este paso es importante porque crea un conjunto de datos "maestro" con las respuestas correctas, que sirve como base para el entrenamiento del modelo, y se agiliza mediante atajos de teclado y funciones de auto-etiquetado.
Con los datos ya etiquetados, entra en juego el script final, clasificar_visualizar_cartas_paso3.py. Este programa permite elegir entre varios tipos de clasificadores (KNN, SVM, Red Neuronal, etc.) y lo entrena con la información previa, enseñándole a reconocer los distintos motivos a partir de sus vectores numéricos. Una vez entrenado, el modelo se pone a prueba con nuevas cartas que no había visto antes. Predice el palo y la figura de cada carta utilizando un sistema de votación por mayoría entre los motivos detectados en ella. El proceso culmina con la visualización de los resultados, incluyendo una evaluación de la precisión del modelo y una representación gráfica de las cartas clasificadas, que se marcan con un borde de color para indicar si el resultado fue correcto o incorrecto.
